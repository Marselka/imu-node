// This program publishes imu data from usb port
#include <ros/ros.h>
#include <sensor_msgs/Imu.h>        // sensor_msgs::Imu
#include <string>                   // std::string std::stod
#include <iostream>                 // std::stringstream std::cout
#include <serial/serial.h>          // serial::Serial serial::Timeout::simpleTimeout
#include <vector>                   // std::vector
#include <sstream>                  // std::stringstream
#include <exception>                // std::exception
#include <sstream>
#include <boost/numeric/ublas/vector.hpp>
#include <boost/numeric/ublas/io.hpp>
#include <boost/math/constants/constants.hpp>
//#include <chiki-briki_i_v_damki.h>
// constants
std::string TOPIC0 = "imu0", TOPIC1 = "imu1";
std::string PORT = "/dev/ttyUSB0";  // port name
const int BAUD = 2000000;            // for incoming data
int LINE_LENGHT = 90;               // lengh of string line coming from imu
int RATE = 10000;                   // frequency to publish at
int TIMOUT = 10;                    // delay in ms
int VALUES_NUMBER = 20;
uint16_t FRACT_NUMBER = 32767; 
double g = 9.81;
const double pi = boost::math::constants::pi<double>();
int TEMP_BUF_SIZE = 800;
// m s ss c0 acc1x acc1y acc1z temp1 gyro1x gyro1y gyro1z c1 acc2x acc2y acc2z temp2 gyro2x gyro2y gyro2z 

std::vector<int16_t> string_to_ints(std::string str) { 
	std::stringstream ss;	 
	/* Storing the whole string into string stream */
	ss << str; 
	/* Running loop till the end of the stream */
	std::string temp; 
	int found; 
	
	std::vector<int16_t> imu_ints;        

	while (!ss.eof()) { 
		/* extracting word by word from stream */
		ss >> temp; 
		/* Checking the given word is integer or not */
		if (std::stringstream(temp) >> std::hex >> found) {
			//std::cout << static_cast<int16_t>(found) << " "; 
			imu_ints.push_back(static_cast<int16_t>(found));
		}
		/* To save from space at the end of string */
		temp = ""; 
	} 
	//std::cout << std::endl;
return imu_ints;
} 

ros::Time imu_ints_to_board_ts(std::vector<int16_t> imu_ints) {
	ros::Time board_ts;
	double secs;

	secs = imu_ints[0] * 60.0 + imu_ints[1] * 1.0 + (FRACT_NUMBER - imu_ints[2])/(FRACT_NUMBER + 1.0);
	board_ts = ros::Time(secs);

	return board_ts;
}

boost::numeric::ublas::vector<double> imu_ints_to_acc(std::vector<int16_t> imu_ints, uint8_t flag) {
	boost::numeric::ublas::vector<double> acc(3);
	boost::numeric::ublas::vector<int16_t> acc_ints(3);
	//std::vector<int> 
	//std::copy(imu_ints[4], imu_ints[6], acc_ints);
    if (flag == 0) {
    	acc_ints[0] = imu_ints[4];
    	acc_ints[1] = imu_ints[5];
    	acc_ints[2] = imu_ints[6];
    }
    if (flag == 1) {
        acc_ints[0] = imu_ints[12];
        acc_ints[1] = imu_ints[13];
        acc_ints[2] = imu_ints[14];
    }
	acc = acc_ints/16384.0*g;
	return acc;
}

boost::numeric::ublas::vector<double> imu_ints_to_gyro(std::vector<int16_t> imu_ints, uint8_t flag) {
	boost::numeric::ublas::vector<double> gyro(3);
	boost::numeric::ublas::vector<int16_t> gyro_ints(3);
	//std::vector<int> 
	//std::copy(imu_ints[4], imu_ints[6], acc_ints);
    if (flag == 0) {
    	gyro_ints[0] = imu_ints[8];
    	gyro_ints[1] = imu_ints[9];
    	gyro_ints[2] = imu_ints[10];
    }
    if (flag == 1) {
        gyro_ints[0] = imu_ints[16];
        gyro_ints[1] = imu_ints[17];
        gyro_ints[2] = imu_ints[18];
    }
	gyro = gyro_ints / 131.0 / 180.0 * pi;
	return gyro;
}

std::vector<std::string> split(std::string string_line, char delimeter) {
    // splits line into a vector of str values
    std::stringstream ss(string_line);
    std::string item;
    std::vector<std::string> splitted;
    while (std::getline(ss, item, delimeter))
        splitted.push_back(item);
    return splitted;
}

std::vector<double> strings_to_doubles_vector(std::vector<std::string> strings_vector) {
    // converts  vector of strings to vector of doubles
    std::vector<double> doubles_vector;
    double imu_val;
    std::string::size_type sz; // size_type

    for (int i = 0; i < strings_vector.size(); i++) {
        try {
            imu_val = std::stod(strings_vector[i], &sz); }
        catch(std::exception& ia) {
            imu_val = 0.0;} // todo what value should be used if "-" or "@" or " " is recieved from imu ?
        doubles_vector.push_back(imu_val);
    }
    return doubles_vector;
}

void publish_imu(ros::Publisher imu_pub, std::string topic, ros::Time ts, boost::numeric::ublas::vector<double> acc, boost::numeric::ublas::vector<double> gyro) {
    // publish_imu data [a in m/s^2] and [w in rad/s]
    sensor_msgs::Imu imu_msg;
    imu_msg.header.frame_id = topic;
    imu_msg.header.stamp = ts;
    // linear_acceleration
    imu_msg.linear_acceleration.x = acc[0];
    imu_msg.linear_acceleration.y = acc[1];
    imu_msg.linear_acceleration.z = acc[2];
    // angular_velocity
    imu_msg.angular_velocity.x = gyro[0];
    imu_msg.angular_velocity.y = gyro[1];
    imu_msg.angular_velocity.z = gyro[2];
    // Publish the message.
    imu_pub.publish(imu_msg);
}


int main(int argc, char **argv) {
    bool board_starting_ts_is_read = false;
    std::string str;
    std::string num;
    /*std::string st;
    uint8_t koko[497];
    int bb;*/
    std::stringstream ss;

    std::vector<int16_t> imu_ints;
    ros::Time sys_starting_ts, board_starting_ts, ts;
    ros::Duration delta_ts;
    boost::numeric::ublas::vector<double> acc;
    boost::numeric::ublas::vector<double> gyro;
    // Initialize the ROS system and become a node.
    ros::init(argc, argv, "publish_velocity");
    ros::NodeHandle nh;

    // Create a publisher object.
    ros::Publisher imu_pub0 = nh.advertise<sensor_msgs::Imu>(TOPIC0, 10000);
    ros::Publisher imu_pub1 = nh.advertise<sensor_msgs::Imu>(TOPIC1, 10000);

    // open port, baudrate, timeout in milliseconds
    serial::Serial my_serial(PORT, BAUD, serial::Timeout::simpleTimeout(TIMOUT));

    // check if serial port open
    std::cout << "Is the serial port open?";
    if(my_serial.isOpen())
        std::cout << " Yes." << "\n";
    else
        std::cout << " No." << "\n";

    // define variables
    //const char delimeter = ',';
    //std::string imu_data_line;
    //std::vector<std::string> imu_strings_vector;
    //std::vector<double> imu_doubles_vector;

    // Loop at RATE Hz until the node is shut down.
    //ros::Rate rate(RATE);
    sys_starting_ts = ros::Time::now();
    while(!board_starting_ts_is_read) {
    	//ROS_INFO("nothing");
            
        // read
        str = my_serial.readline(); 
        //std::cout << str << std::endl;
		if (str.size() == LINE_LENGHT){
            imu_ints = string_to_ints(str);
            delta_ts = sys_starting_ts - imu_ints_to_board_ts(imu_ints);
            board_starting_ts_is_read = true;
        }
	}

    while(ros::ok()) {
        //std::cout << "her1" << std::endl;
        // read
        ss << my_serial.readline(); 
        //std::cout << "her" << std::endl;
    	/*bb = my_serial.read(koko, 497);
    	std::cout << bb << std::endl;
    	std::cout << "========" << std::endl;
		std::cout << koko << std::endl;
    	std::cout << "========" << std::endl;*/
    	//ss << str;
    	//st += str;
    	//std::cout << st.size() << std::endl;
    	//ss.seekg(0, std::ios::end);
		//stringstream::pos_type offset = oss.tellp();
		//std::cout << ss.tellp() << std::endl;
		while(ss.tellp() - ss.tellg() > TEMP_BUF_SIZE) {
			std::getline(ss, str);
			//std::cout << str << " | " << ss.tellp() - ss.tellg() << std::endl;
			//std::cout << str.size() << std::endl;
			if (str.size() == LINE_LENGHT) {
	            imu_ints = string_to_ints(str);
	            ts = imu_ints_to_board_ts(imu_ints) + delta_ts;
	            acc = imu_ints_to_acc(imu_ints, 0);
	            gyro = imu_ints_to_gyro(imu_ints, 0);

	            //std::cout << ts << " " << ros::Time::now() << " " << acc << " " << TOPIC+"1" << " " << gyro << std::endl;
				
			
			    //std::string imu_data_line = my_serial.read(LINE_LENGHT);
			    // split
			    //imu_strings_vector = split(imu_data_line, delimeter);
			    // convert
			    //imu_doubles_vector = strings_to_doubles_vector(imu_strings_vector);
			    // publish
                //num = "0";
			    publish_imu(imu_pub0, TOPIC0, ts, acc, gyro);
                
                acc = imu_ints_to_acc(imu_ints, 1);
                gyro = imu_ints_to_gyro(imu_ints, 1);
                publish_imu(imu_pub1, TOPIC1, ts, acc, gyro);
			    // Wait until it's time for another iteration.
			    //rate.sleep();
	        }
	    }
    }
}
